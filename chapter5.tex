% Guidance - 3 pages
% Description and discussion of your individual component solution, detailing
% the technical innovation and implementation and details of your testing
% strategy, and the results. 
\section{Description of Individual Component Solution}

My individual contribution to the project consisted primarily of a shell style 
interface for the host board, allowing user interaction via a computer keyboard 
and monitor, but also consisted of the modification and extension of previously 
existing LCD screen code, to allow a much greater degree of control over the 
attched LCD display. 

The shell style interface was set up using an interrupt based system from the 
computer. This enables users to enter commands through any input method for 
the computer and process them on the device. This method also allows the user
to display useful information through the computer monitor.

There were a wide range of possible input commands available through this interface, 
with many possible options and settings being adjusted on the fly. By typing 'help' and 
pressing enter, the user could view a list of possible commands, as seen below: 

"List of available commands:\par\bigskip\noindent
playnote note volume   : plays the selected midi note\par\noindent
noteoff note           : turns off any playing notes\par\noindent
volume <vol>           : sets the output volume to 'vol'\par\noindent
showvol                : displays the current volume\par\noindent
write "text"           : writes text to the LCD screen\par\noindent
writeline "text" <linenumber> : writes text to one line of the 
LCD screen\par\noindent
listen                 : listens to music on the CAN bus\par\noindent
stoplisten             : stops listening to music on the CAN bus\par\noindent
setid <channel>        : Filters out channels that do not match 
channel number 'channel'. 
To play all, use "setid all\par\noindent
showid                 : Shows the id of the current channel\par\noindent
showtrack              : Shows the current track name on the LCD\par\noindent
showchan               : Scrolls the channels on the LCD\par\noindent
showpacket             : Prints CAN packets until a key is pressed\par\noindent
scroll \"text\" <line> : displays scrolling text on line <line> of the 
LCD screen\par\noindent
stopscroll <line>      : stops scrolling text on the screen. To stop both lines, 
enter <line> as 2 or all.\par\noindent
scrollenable <line>    : enables scrolling text on the screen.\par\noindent
shownotes              : displays all notes currently being played\par\noindent
cowsay \"text\"        : displays an ASCII cow, saying text\par\noindent
clear <line>           : clears any text that is on the lcd line <line> 
Note - you may also have to call stopscroll to fully clear\par\noindent
\par\bigskip\noindent
This therefore provides the user with a high amount of control over the devices 
output though both audio and visual elements, as well as a high level of control 
over the devices functionality. Furthermore, the interaction with 
the on board LCD display can be clearly seen through the above commands, hence 
explicating the necessity for the alterations made to LCD display code to permit 
a greater degree of control, and enable features such as scrolling text, and 
writing to only part of the LCD screen. 

\section{Discussion of Technical Innovation and Implementation}

The implementation of the shell style interface and the improvement of the LCD 
display code consists of many different technical challenges, and required many 
different technical challenges throughout. First and foremost there was the 
challenge of setting up a system to enable user input to be recognised. This is 
achieved using an interrupt based system, such that each new character entered into 
a screen set up for the board will trigger an interrupt. When the interrput is 
triggered, the character that was input is transferred to the host board and stored into 
memory for processing at a later stage. This incorporated several different technical 
challenges in the implementation, such as figuring out how to set up the interrput, and 
how to allocate memory for storing any characters input. The simplest solution for 
allocating memory was used: a set input limit is defined, and any characters that are 
input past this count are not stored in memory. Other technical challenges involved handling 
special input cases such as backspace to delete a character from memory, but only if there 
was any input to delete. 
\par\bigskip\noindent
When the enter key is pressed (\r\n received on the interrput), processing of the user's 
input command begins. 
First the text is split up into tokens for processing. This 
requires the use of a text parser. The text parser implemented uses a state based system,
with different states corresponding to whether it is interpreting a single word, a phrase 
(group of words encased in quotation marks), or whitespace. This breaks the user's 
command into it's constituent components, which can then be individually evaluated. 
However, it was found that memory allocation problems could occur due to the large range of 
possible tokens in the input. For example, the user could input 'a a a a a a', and this 
would be interpreted as 6 individual tokens, requiring the allocation of six blocks of 
memory. A solution to this problem was found by simply setting a limit on the number 
of tokens that can be generated by a single command. 
\par\bigskip\noindent
Following the disection of the user's input into components, a string comparison tool (strcmp)
was used to determine what the user's input was, enabling the corresponding desired 
behaviour to be executed. In order to prevent race conditions from occuring within in the 
interrupt handler, all text processing following the enter key being pressed occurs 
outside of the interrupt handler using a flag based system. 


\section{Testing Strategy, and the Results}
