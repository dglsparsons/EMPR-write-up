% Guidance - 3 pages
% Description and discussion of your individual component solution, detailing
% the technical innovation and implementation and details of your testing
% strategy, and the results. 
\section{Description of Individual Component Solution}

My individual contribution to the project consisted primarily of a shell style 
interface for the host board, allowing user interaction via a computer keyboard 
and monitor, but also consisted of the modification and extension of previously 
existing LCD screen code, to allow a much greater degree of control over the 
attached LCD display. 
\par\bigskip\noindent
The shell style interface was set up using an interrupt based system from the 
computer. This enables users to enter commands through any input method for 
the computer and process them on the device. This method also allows the user
to display useful information through the computer monitor.
\par\bigskip\noindent
There were a wide range of possible input commands available through this 
interface, with many possible options and settings being adjusted on the fly. 
By typing 'help' and pressing enter, the user could view a list of possible 
commands, as seen below: 

\begin{table}[h]
\begin{tabular}{lp{8cm}}
List of available commands:\par\bigskip\noindent & \\
playnote note volume   & : plays the selected midi note\\
noteoff note           & : turns off any playing notes\\
volume vol           & : sets the output volume to 'vol'\\
showvol                & : displays the current volume\\
write text           & : writes text to the LCD screen\\
writeline text linenumber & : writes text to one line of the 
LCD screen\\ 
listen                 & : listens to music on the CAN bus\\
stoplisten             & : stops listening to music on the CAN bus\\
setid channel        & : Filters out channels that do not match 
channel number channel. To play all, use setid all\\
showid                 & : Shows the id of the current channel\\
showtrack              & : Shows the current track name on the LCD\\
showchan               & : Scrolls the channels on the LCD\\
\end{tabular}
\end{table}
% 2 tables because there's a page break in between
\begin{table}[h]
\begin{tabular}{lp{10cm}}
showpacket             & : Prints CAN packets until a key is pressed\\
scroll text line & : displays scrolling text on line line of the 
LCD screen\\
stopscroll line      & : stops scrolling text on the screen. To stop both lines, 
enter line as 2 or all.\\
scrollenable line    & : enables scrolling text on the screen.\\
shownotes              & : displays all notes currently being played\\
cowsay text        & : displays an ASCII cow, saying text\\
clear line           & : clears any text that is on the lcd line line 
Note - you may also have to call stopscroll to fully clear\\
\end{tabular}
\end{table}

\par\bigskip\noindent
This therefore provides the user with a high amount of control over the devices 
output though both audio and visual elements, as well as a high level of control 
over the devices functionality. Furthermore, the interaction with 
the on board LCD display can be clearly seen through the above commands, hence 
explicating the necessity for the alterations made to LCD display code to permit 
a greater degree of control, and enable features such as scrolling text, and 
writing to only part of the LCD screen. 

\section{Discussion of Technical Innovation and Implementation}

The implementation of the shell style interface and the improvement of the LCD 
display code consists of many different technical challenges, and required many 
different technical challenges throughout. First and foremost there was the 
challenge of setting up a system to enable user input to be recognised. This is 
achieved using an interrupt based system, such that each new character entered 
into a screen set up for the board will trigger an interrupt. When the 
interrupt is triggered, the character that was input is transferred to the host 
board and stored into memory for processing at a later stage. This incorporated 
several different technical challenges in the implementation, such as figuring 
out how to set up the interrupt, and how to allocate memory for storing any 
characters input. The simplest solution for allocating memory was used: a set 
input limit is defined, and any characters that are input past this count are 
not stored in memory. Other technical challenges involved handling special input 
cases such as backspace to delete a character from memory, but only if there 
was any input to delete. 
\par\bigskip\noindent
When the enter key is pressed (\textbackslash r\textbackslash n received on 
the interrupt), processing of the user's input command begins. 
First the text is split up into tokens for processing. This 
requires the use of a text parser. The text parser implemented uses a state 
based system, with different states corresponding to whether it is interpreting 
a single word, a phrase (group of words encased in quotation marks), or 
whitespace. This breaks the user's command into it's constituent components, 
which can then be individually evaluated. However, it was found that memory 
allocation problems could occur due to the large range of possible tokens in 
the input. For example, the user could input 'a a a a a a', and this would be 
interpreted as 6 individual tokens, requiring the allocation of six blocks of 
memory. A solution to this problem was found by simply setting a limit on the 
number of tokens that can be generated by a single command. 
\par\bigskip\noindent
Following the disection of the user's input into components, a string 
comparison tool (strcmp) was used to determine what the user's input was, 
enabling the corresponding desired behaviour to be executed. In order to 
prevent race conditions from occurring within in the interrupt handler, all text 
processing following the enter key being pressed occurs outside of the interrupt 
handler using a flag based system.
\par\bigskip\noindent
In order to successfully perform the desired functionality, settings are altered 
within many different areas of the project. The implementation of the shell 
therefore required a fully detailed understanding of how each individual 
component of the project functions in order to manipulate and alter existing 
code. Modifications were made throughout the project, and included; the addition 
of a settable id within the CAN bus code, the addition of a filter in the CAN 
bus to ignore unwanted data according to the preset id, the addition of a 
volume control in the synth code, and a major overhaul of existing LCD code to 
allow a much greater degree of control over the display. 
\par\bigskip\noindent
The overhaul of the LCD display code provided a significant technical challenge. 
The initial desire was simply to allow scrolling text on the display, however 
it soon became clear that further alterations were required. Initially the LCD 
code would write to the LCD display, and clear it. To match what I wished to 
achieve, it was necessary to first figure out how to write only to a single 
line of the LCD display, without clearing the other line. This required 
accessing only certain memory addresses of the LCD display buffer in order to 
prevent clearing parts of the display. Following the successful implementation 
of the capability to write to each individual line of the LCD display, the next 
target was to give the ability to scroll text across the display, in order to 
effectively increase the number of characters that could be read. 


\section{Testing Strategy, and the Results}

Due to the nature of the extension project, testing was relatively straightforward. 
Using the debugging library, it was very easy to check the effects of any command 
that was entered to ensure correct behaviour. Therefore, any errors or undesirable 
behaviour was rapidly discovered. Furthermore, the interface became a central 
aspect of the group solution, and as a result was used by each member of the 
group on a regular basis to interact with the device. Through each individuals 
interaction many test cases were encountered, and therefore the device has 
undergone a continual and thorough testing strategy.
\par\bigskip\noindent
The results of the testing strategy were very positive. The shell style interface 
had a large number of features by the end of the project, and worked very well. 
Furthermore, my individual contribution provided a very valuable tool throughout 
the project due to the high level of interaction that it provided. 
