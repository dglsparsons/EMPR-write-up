% Guidance - 4 pages
% Description and discussion of the TEAM solution, noting how the team broke
% down the problem for team members and detailing the technical innovation and
% implementation of the work.
\section{Description of the Team Solution}

The end product of our team solution was a successful working product. Through the 
incorporation of a Linux style shell into the group solution, we managed to produce 
a highly configurable single solution that managed to satisfy each section of 
specification. In addition the group solution contained two custom built speakers, 
capable of being powered by the 5V voltage rails from the peripherals board. 
The solution had a strong user interface, allowing the user to type in commands 
through the computer keyboard to adjust settings and select modes, set an id 
to filter channels out, and display information, or custom text on the mbed 
board. In addition it was also possible to adjust volume, channel and display 
information on the mbed board using the 16 digit keypad. This high level of 
user interfacing allowed settings to be flexibly turned on and off, and 
avoided the need to be continually re-installing binaries to the device. 
By typing in the command "listen", the mbed would then initialise the CAN bus 
and begin receiving packets. These could be printed out to the screen by issuing
a further command, or they could be used to generate audio tones. It is also 
possible to filter out data according to a preset id by issuing a command, or 
using the keypad. For each data element received, audio tones can be generated. 
The solution supports a full synthesis, allowing multiple notes to be played
on each channel, and multiple channels to play notes simultaneously. In addition 
the audio output also implemented an 'attack-sustain-release' model, creating a 
more realistic sounding solution. The audio code used direct memory access (DMA)
to provide a reduced processing cost in outputting the audio samples.
The user could also choose to display useful information such as the current 
song name, the volume, or the channel names on the computer screen or on the 
MBED board in a variety of ways. For example they could be statically printed on
the MBED board, or scrolled across the LCD display, or even printed out to 
the terminal on the computer.

\section{How the problem was broken down for individual members}

The breakdown of our solution into components individual members could work on 
was a great strength of our team. Each person worked on as aspect of the project 
that they found interesting, and throughout the project we had regular feedback 
on all our work in order to make sure we were meeting our specifications and 
that nobody was out of their depth. Below I have divided up the work that each 
individual completed during the duration of the project, and why they were 
working on that aspect of the project. 

\subsection*{Mingzhao Zhao}
Each individual was allowed to choose their own area of the project to work on. 
Mingzhao was not especially confident with the platform, and therefore he 
decided to target user interaction with the device via the keypad. This 
provided a possible method of user input, as well as providing a means to 
optionally filter data, or control the volume output of the device. 
Following suggestions 
of other group members he decided to convert the previous keypad polling method 
incorporated in the mini-projects into an interrupt based system, removing the 
need for unnecessary CPU cycles to be used polling the device continually. 

\subsection*{Shivam Mistry} 
Shivam worked very strongly as a group member. To begin with he took on the 
challenge of constructing code to read the data from the CAN bus continually, 
as well as implementing the base for filtering out data according to a preset ID
. Following the construction of the CAN bus code, he worked on optimising the 
CAN bus code through the
implementation of a queue, as well as decoding the CAN packets to extract their
data, and the parsing of text packets to extract only the useful information. 
Furthermore, on realisation of additional device memory, Shivam wrote a memory 
allocator allowing the additional memory to be used constructively, further 
optimising the system. 

\subsection*{Myself (Douglas Parsons)}
Following the mini projects, and from reviewing the specification, it was clear 
that a strong level of user interaction with the device would provide valuable 
debugging tools, could potentially allow settings to be changed without 
re-installing binaries on the device, and could be used for a wide range of 
useful functions, such as changing the volume or displaying song information. 
From the mini projects it became clear that the 16 digit keypad attached to the 
mbed would not provide an intuitive user experience. Rather than relying on 
the keypad as the sole method of user interaction, I instead focused 
on allowing a further degree of interaction via the computer keypad. This 
enabled the user to preset an ID to filter out data, adjust the volume of the 
output, display any data received on the CAN bus, as 
well as adjust settings within the project without requiring a full reinstate.
During the implementation of the shell it became clear that this could be a 
valuable tool for displaying useful information such as the song name, and 
therefore I additionally worked with the LCD display to enable a much greater 
degree of control over what was displayed, enabling scrolling text, and writing 
to each line of the display individually.

\subsection*{Liam Fraser}
Liam has a strong background in music technology, taking the subject at A-level,
and working on personal projects involving music. Furthermore his interest from 
the beginning of the project in audio processing meant that it was an obvious 
choice for Liam to look into the generation and playback of music. The 
specification was exceeded with his contributions, not only did his solution 
generate an audio tone corresponding to the frequency, duration, and volume 
levels specified in the data stream, but implemented an attack sustain release 
curve to improve the realism of the output sound, as well as additive synthesis 
enabling multiple notes to be played simultaneously, and his solution also 
used DMA and a fixed point library to improve the efficiency of the system. 

\section{Technical innovation and implementation of each member}
\subsection*{Mingzhao Zhao}
Mingzhao's work was primarily focused on implementing interaction via 
the 16 digit keypad on the mbed board. The keypad was set up in the mini-projects 
to allow user interaction through continually polling the keypad. However, due 
to the limited speed of the processor it was decided that a better solution 
would be to use an interrupt based system.
However, this caused additional problems with bounce on the switches: 
multiple interrupts could occur in a very short space of time due to bounces on 
the switches. Many of these interrupts generated were redundant, or gave 
nonsensical input values, and furthermore their rapidity caused race conditions 
to occur within the interrupt handler. 
Due to the row/column method in which the key pad is scanned, the 
number of bounces was reduced significantly by filtering out any inputs that 
did not match one of the keys pressed. The switch bounces were then reduced 
further by only allowing a single key press every half a second. 
This method of debounce was implemented using a system 
timer (SysTick) to count the time between successive key presses. Any key 
presses that occurred too closely together were disregarded. 

\subsection*{Shivam Mistry}
Shivam initially targeted the CAN bus, and was able to rapidly achieve a fully 
functioning prototype. The original solution processed each packet as it was 
received. However, as the complexity of songs increased it became clear that this 
simplistic method was not going to be sufficient when many CAN packets require 
processing in a short space of time.
In order to improve the functionality, a queue was implemented. Packets were 
added to the queue on being received, and processed whenever there was sufficient
processor resources available.
This removed the requirement of each packet being processed as it was received,
 and therefore provided a clean, efficient solution.
Shivam's contribution also included the reverse engineering and decoding of any
 CAN packets received through testing their check-sum, and parsing any received 
text.
As the check-sum method was not specified in any documentation, the first 
challenge was determining what the check-sum corresponded to. Values that did 
not match the length specified by the check-sum were not processed, and therefore 
could not have any impact on the system. Furthermore, the text packets sent prior 
to each song being played required parsing in order to extract any useful 
information. Therefore, a text parser, extracting the useful information from 
these packets to the device was implemented using a state based solution. 

Furthermore, following an 
instance where the physical memory (RAM) on the device was fully used up, Shivam 
discovered that the device contains an additional 32Kb of memory, 
typically reserved for communicating to a USB or Ethernet device. However, 
due to the reserved status of this memory, a memory allocator was required for 
it to be utilised. 
Therefore, the group solution contains a memory allocator allowing access to 
a further 32Kb of memory. This allows a much greater amount of information to be 
stored on the device. 
In addition, the look-up table used by the memory allocator was stored in the 
additional memory, making it a self containing allocator. 

\subsection*{Myself (Douglas Parsons)}

My personal contribution to the project was primarily targeted at the user 
interactions with the device. While it was initially set out that Mingzhao was 
going to work on implementing an interrupt based keypad, I decided that the 
communication via serial would potentially allow a much greater level of 
debugging, interaction, and manipulation of settings for the device. From the 
beginning of the ten week period, I focused on setting up a shell style interface 
for the device. This would allow the user to communicate with the mbed board by 
typing in commands on a computer keyboard, and execute the command by pressing 
the enter key. The input from the keyboard was implemented using interrupts in 
order to avoid unnecessary computation time from continual polling. 
Furthermore, the processing of text input required a text-parser to be used. 
Due to an unknown number of words, and an unknown input length, the parser had 
to be very carefully adjusted to avoid memory overflow situations. Further 
difficulty was added to the implementation, as alterations had to be made in many 
different aspects of the group solution. A detailed understanding of each 
individuals contributions was required to manipulate their functionality, and 
continual additions and updates were needed throughout the project as changes 
were made. 
In addition to implementing the additional interfacing method of a shell style 
interface, I focused on customisation of the mini-project LCD screen code in 
order to allow a greater level of control. I implemented features such as the 
ability to write to each individual line of the LCD display, and the ability to 
scroll text across the screen. 
The latter of which was particularly difficult, not only requiring pointer 
manipulation for efficient text processing, but accessing only the required 
section of the LCD in order to avoid displaying unwanted characters provided 
a significant technical challenge. Following the implementation of the shell, and 
the LCD screen code, 
I worked alongside Mingzhao on combining his code with 
the rest of the group solution. 

\subsection*{Liam Fraser}
Liam Fraser, following an interest in music technology was eager to work on the 
audio code for the project. He implemented a simplistic system, allowing musical 
notes to be generated by scanning, and interpolating over a look up table. He then 
looked into generating synthesised music, and implemented additional synthesis 
into the project, allowing multiple notes to be playing simultaneously. However, 
on testing his synthesis code on the mbed board, it rapidly became apparent that 
the use of floating point numbers was not sufficiently quick to produce clean 
sounding audio. Therefore, a fixed point library was implemented, this allowed 
much quicker calculations to occur compared to those of floating point numbers. 
Following this optimisation of the synthesis code, the synth code was further 
optimised through the use of Direct Memory Access (DMA). This allowed the audio 
output to work independent of the central processing unit (CPU). This 
therefore speeds up the processing of any audio, as the CPU does not have to be 
involved for any sound to be output, only for the generation of audio samples 
\cite{dma-book}. In addition, to create a more realistic sounding output from the 
device, an attack sustain release state model was incorporated for each note. 
This gives an initial rise in volume as the note is turned on, and a fading out 
of the note as it is turned off, producing a volume curve more typical of an 
actual instrument \cite{asr-book}.

